<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ORACLE DATABASE Notes</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="img/favicon.ico">
    <script defer src="JS/weather.js"></script>
</head>
<body>
    <div class="rightSector">
        <a class="oracleSector" href="https://chlee21.tistory.com/69">ORACLE 연습문제</a>
        <br>
        <br>
        <a class="oracleSector" href="https://mine-it-record.tistory.com/category/DBMS/ORACLE">ORACLE 기본</a>

    </div>

    <header class="headerTop">
        <!-- <h1>ORACLE DATABASE</h1> -->
        <div class="logo"></div>
        <div id="weather">
            <span></span> &
            <span></span>°C <br>
            <span></span>
        </div>
    </header>

    <header class="headerBot">
        <a href="index.html">ORACLE</a>
        <!-- <a href="https://chlee21.tistory.com/69" target="_blank">WORK</a>
        <a href="https://mine-it-record.tistory.com/category/DBMS/ORACLE" target="_blank">CENTER</a> -->
        <a href="shop.html">Spring</a>
    </header>

    <section>
        <div class="tag1 220624">
            <div class="tag2">
                <h2>Schema</h2>
                <br>
                <p>
                    서로 연관된 표들을 그룹핑하는 일종의 디렉토리. (스키마에 속한 표들이 어떤 정보를 갖는지 설명하는 것.)
                </p>
            </div>

            <div class="tag2">
                <h2>관리자 및 사용자 생성</h2>
                <br>
                <p>
                    <strong>관리자.</strong>System As System DataBase Admin <br>
                    cmd 창에서 sqlplus를 입력하여 오라클을 실행 후, <br>
                    sys AS SYSDBA 후 엔터 하면 password 입력하라고 뜨는데 그냥 비워두고 다시 Enter 눌러도됨 <br>
    
                    <br>
                    <strong>사용자</strong><br>
                    CREATE USER [ID] IDENTIFIED BY [PWD] <br>
                    그러나 생성이 안될경우 alter session set "_ORACLE_SCRIPT"=true; 명령어를 실행하여 세션을 변경해준다. ORACLE 11g 에서 사용하는 방법임. <br>
                    이후 생성된 사용자 계정에 권한을 부여해줘야 계정을 사용할 수 있게 된다.  <br>
                    우선 관리자로 로그인한 뒤 GRANT DBA TO [ID]; 를 하면 권한을 줄 수 있다. <br>
                    중간의 DBA는 어떤 권한을 줄지를 선택해주는 단어이다. 데이터베이스는 관리자와 사용자의 권한을 나눠서 이원화시켜 관리하는것이 바람직하기때문에 DBA라는 최상위 권한을 주는것은 옳지 않지만, 여기서는 공부를 위해 사용하므로 DBA라는 높은 권한을 주었다. <br>
                </p>
            </div>

            <div class="tag2">
                <h2>정의</h2>
                <br>
                <p>
                    DDL - CREATE / ALTER / DROP <br>
                    DML - INSERT / SELECT / UPDATE / DELETE -> CRUD <br>
                    DCL - GRANT / REVOKE <br>
                </p>
            </div>

            <div class="tag2">
                <h2>Table 생성</h2>
                <br>
                <p>
                    CREATE TABLE topic ( <br>
                    &emsp;    id  NUMBER NOT NULL, <br>
                    &emsp;    title VARCHAR2(50) NOT NULL, <br>
                    &emsp;    description VARCHAR2(4000) NULL, <br>
                    &emsp;    created DATE NOT NULL <br>
                    ); <br>
                    <br>
                    <strong>설명</strong><br>
                    NUMBER - 숫자만 들어옴  <br>
                    VARCHAR2(num) - 괄호안의 글자수 까지만 문자열이 들어옴  <br>
                    DATA - 날짜가 들어오는 ORACLE 구문. <br>
                    NOT NULL - 비어있어선 안된다.   <br>
                    NULL - 비어있어도 된다. 이 경우에 그냥 NULL도 안써도됨. <br>
                </p>
            </div>

            <div class="tag2">
                <h2>생성된 테이블 확인</h2>
                <br>
                <p>
                    테이블을 선택하는 방법 <br>
                    SELECT table_name FROM all_tables WHERE OWNER = 'AYH'
                </p>
            </div>

            <div class="tag2">
                <h2>SQL</h2>
                <br>
                <p>
                    Structured Query Language.<br>
                    구조화된 정보를 처리하도록 요청하는 컴퓨팅 언어.
                </p>
            </div>

            <div class="tag2">
                <h2 class="redline">행 추가, CREATE, INSERT</h2>
                <br>
                <p>
                    INSERT INTO topic <br>
                    &emsp;   (id,title,description,created) <br>
                    &emsp;   VALUES <br>
                    &emsp;   (1,'ORACLE','ORACLE is ...',SYSDATE); <br>
                    <br>
                    이후 commit; 을 해줘야함. commit을 하지 않으면 행을 몇개를 추가하든 실제로 반영이 되지는 않음. 깃허브의 psuh를 생각해보자.
                </p>
            </div>

            <div class="tag2">
                <h2 class="redline">행 읽기, Read</h2>
                <br>
                <p>
                    전체 읽기 <br>
                    SELECT * FROM topic; <br>
                    <br>
                    특정 열 값만 읽기 <br>
                    SELECT id, title, created FROM topic; <br>
                    <br>
                    특정 행 값만 읽기 <br>
                    SELECT * FROM topic WHERE id = 1; <br>
                    SELECT * FROM topic WHERE id > 1; <br>
                    <br>
                    특정 행렬만 읽기(가로 세로 모두 필터링) <br>
                    SELECT id, title, created FROM topic WHERE id = 1;
                </p>
            </div>

            <div class="tag2">
                <h2>정렬</h2>
                <br>
                <p>
                    높은 숫자부터 정렬 <br>
                    SELECT * FROM topic ORDER BY id DESC; <br>
                    <br>
                    낮은 숫자부터 정렬 <br>
                    SELECT * FROM topic ORDER BY id ASC; <br>
                    <br>
                    숫자로 할꺼면 id, 타이틀로 할꺼면 title로 하면 되며 알파벳 순서로 DESC, ASC를 따른다.<br>
                    SELECT * FROM topic <br>
                    &emsp;    OFFSET 1 ROWS <br>
                    &emsp;    FETCH NEXT 2 ROWS ONLY; <br>
                    <br>
                    OFFSET - 특정 행의 "다음" 부터 출력. 즉 OFFSET 1을 하면 2부터 출력됨. <br>
                    FETCH - 다음 [num] 개의 행만 출력
                </p>
            </div>

            <div class="tag2">
                <h2 class="redline">행 수정, UPDATE</h2>
                <br>
                <p>
                    UPDATE topic <br>
                    &emsp;        SET<br>
                    &emsp;&emsp;            title = 'MSSQL',<br>
                    &emsp;&emsp;           description = 'MSSQL is...'<br>
                    &emsp;        WHERE<br>
                    &emsp;&emsp;            id = 3;<br>
                    <br>
                    무엇을 수정할지가 SET에 먼저 나온 뒤, 어디에 있는걸 수정할지 주소값을 입력해줘야한다. <br>
                    UPDATE와 DELETE는 무언가 바뀌는 행위 이므로 수정한 뒤 commit;을 해줘야 반영된다. <br>
                    수정과 삭제는 매우매우 위험한 작업이므로 굉장히 주의깊게 해야한다.
                </p>
            </div>

            <div class="tag2">
                <h2 class="redline">행 삭제, DELETE</h2>
                <br>
                <p>
                    DELETE FROM topic WHERE id = 3; <br>
                    특정한 행을 삭제하는 것. 만약 WHERE id를 지정해주지 않으면 모든 데이터가 날라가버려서 큰일이 발생한다.
                </p>
            </div>

            <div class="tag2">
                <h2>테이블 통째로 삭제</h2>
                <br>
                <p>
                    DROP TABLE topic; <br>
                    테이블을 전부 삭제하고 나서는 commit;을 해줄 필요는 없다.
                </p>
            </div>

            <div class="tag2">
                <h2>PRIMARY KEY. 고유값</h2>
                <br>
                <p>
                    CREATE TABLE topic ( <br>
                    &emsp;    id  NUMBER NOT NULL, <br>
                    &emsp;    title VARCHAR2(50) NOT NULL, <br>
                    &emsp;    description VARCHAR2(4000) NULL, <br>
                    &emsp;    created DATE NOT NULL <br>
                    &emsp;    CONSTRAINT [primary key name] PRIMARY KEY(원하는거 id, title 등등) <br>
                    ); <br>
                    <br>
                    예를들어 id에 PK_TOPIC이라 명명한 PRIMARY KEY를 설정하면 고유한 귀속이 걸려서 같은 넘버로는 행을 추가 할 수 없다. <br>
                    PRIMARY KEY를 지정한 값을 통해 자료를 찾으면 검색 속도가 매우매우 빠르다. <br>
                    만약 id에 PK를 지정하고 1번에 값을 다시 INSERT 하면 무결성제약조건에 위배된다는 메세지가 뜨면서 추가가 되지 않는다. 
                </p>
            </div>
        </div>

        <div class="tag1 220627">
            <div class="tag2">
                <h2>SEQUENCE</h2>
                <br>
                <p>
                    자동적으로 값을 부여해주는 기능.<br>
                    <br>
                    예를 들어 id값을 PRIMARY KEY 기능으로 부여를 해주었을때 새로 데이터를 INSERT 할 때 마다 <br>
                    자동적으로 가장 높은값으로 부여해주는 기능이다. 즉, PRIMARY KEY 기능과 한 세트로 동작한다.<br>
                    CREATE SEQUENCE [NAME]; 을 입력하여 시퀀스를 생성한 후 INSERT 명령문의 id값 또는 원하는 부분에<br>
                    [NAME].NEXTVAL 을 입력해주면 자동으로 id값이 가장 높은 값으로 부여되는 명령문이 완성된다. <br>
                    1을 더하면서 높여주는 값, 10을 더하면서 높여주는 값 등 다양한 옵션을 이용할 수 있음. <br>
                    만약 현재 시퀀스의 가장 높은 값을 알고 싶으면 SELECT SEQ_topicPRIM.CURRVAL FROM DUAL; 을 명령하면 알 수 있음. <br>
                    SELECT SEQ_topicPRIM.CURRVAL FROM topicPRIM; 을 사용해도 알 수 있지만 시퀀스의 값 만큼의 행이 생성되므로 그냥 DUAL이 편하다.
                
                    <br>
                    <br>

                    <strong>시퀀스 생성 명령문</strong>  <br>
                    CREATE SEQUENCE [시퀀스 명] <br>
                    INCREMENT BY [증감숫자]  -- 시퀀스 증가값.(기본값 1), <br>
                    START WITH [시작숫자]    -- 시퀀스 시작값.<br>
                    MAXVALUE [최대값] -- 시퀀스 최대값.(생략시 최대값 무한대 NOMAXVALUE)<br>
                    MINVALUE [최소값] -- 시퀀스 최소값.(생략시 최소값 무한대 NOMINVALUE)<br>
                    CYCLE OR NOCYCLE  -- 기본값은 NOCYCLE 입니다. CYCLE로 지정하면 최대값에 도달했을때 다시 최소값부터 시작합니다.<br>
                    <br>
                    <strong>시퀀스 삭제 명령문</strong> <br>
                    DROP SEQUENCE [시퀀스명];
                </p>
            </div>

            <div class="tag2">
                <h2 class="redline">분해</h2>
                <br>
                <p>
                    데이터를 다룰때는 이를 쪼개서 분산시킬 수 있다. 특정 분류를 코드화해서 보관하면 추후에 엄청난 양의 데이터를 수정해야하는 상황이 발생할 때, <br>
                    매우 간편하게 이를 동시에 전부 바꿀 수 있게 되므로 분류와 조합을 잘 하는것이 중요하다.
                </p>
            </div>

            <div class="tag2">
                <h2 class="redline">조립, Join</h2>
                <br>
                <p>
                    데이터를 분해해두면 추후 관리하기는 좋지만 표를 보기에는 좋지 않다. 그러므로 이를 조립을 해서 보여주면 관리의 용이함과 표의 직관성을 둘 다 잡을 수 있다. <br>
                    <br>
                    SELECT * FROM topic LEFT JOIN author ON topic.author_id = author.id; <br>
                    왼쪽에 topic을, 오른쪽에 author표를 배치하는 것. topic의 author_id와 author의 id가 같은 것을 매칭시켜서 왼쪽과 오른쪽에 각기 배치하는 방법이다. <br>
                    <br>
                    이러한 Relation 기능들 덕에 지난 수십년간 ORACLE과 같은 관계형 데이터베이스가 컴퓨터공학을 지배할 수 있었다. <br>
                    <br>
                    SELECT <br>
                    &emsp;    T.id TOPIC_ID, <br>
                    &emsp;    title,<br>
                    &emsp;    T.description,<br>
                    &emsp;    created,<br>
                    &emsp;    name,<br>
                    &emsp;    PROFILE<br>
                    FROM topic T<br>
                    &emsp;    LEFT JOIN author A <br>
                    &emsp;    ON T.author_id = A.id<br>
                    ; <br>
                    <br>
                    SELECT 아래에는 보고싶은 데이터. T.id 뒤의 TOPIC_ID는 데이터 칸에 들어올 별명.  <br>
                    topic T 는 앞으로 topic을 T로 대신하겠다는 의미. 워크시트에서 T를 topic대신 쓸 수 있다.
                    FROM 아래는 합쳐지는 위치에 대한 정의. LEFT는 원래 있는 T의 기준 위치이며 JOIN 뒤에 오는것은 어떤 테이블을 합칠것인가에 대한 명령문.<br>
                    ON 은 합쳐지는 조건에 대한 정의. 위 워크시트에서는 T의 author_id와 A의 id가 같을때만 합쳐지도록 설정한것이다.
                </p>
            </div>

            <div class="tag2">
                <h2 class="redline">테이블 column 추가, ADD</h2>
                <br>
                <p>
                    테이블 내의 column (열) 을 추가하는 명령문. <br>
                    ALTER TABLE [MEMBER] ADD [EMAIL] [VARCHAR2(200)];
                </p>
            </div>

            <div class="tag2">
                <h2 class="redline">테이블 column 수정, MODIFY</h2>
                <br>
                <p>
                    sql developer의 GUI를 활용해서 수정하는것이 제일 편함. <br>
                    <br>
                    테이블 내부 데이터의 자료형을 수정하는 명령문. <br>
                    ALTER TABLE [MEMBER] MODIFY [ID] [NVARCHAR2 (50)]; <br>
                    <br>
                    테이블 내부 데이터의 이름을 수정하는 명령문. <br>
                    ALTER TABLE [TABLE.NAME] RENAME COLUMN [NAME] TO [NEW NAME];
                </p>
            </div>

            <div class="tag2">
                <h2 class="redline">테이블 column 삭제, DROP</h2>
                <br>
                <p>
                    테이블 내의 column (열)을 삭제하는 명령문. <br>
                    ALTER TABLE [MEMBER] DROP COLUMN [AGE]; <br>
                    <br>
                    테이블 내에서 데이터 자체는 남아있지만 display:none 처럼 값을 숨기는 명령문. <br>
                    ALTER TABLE [TABLE.name] set unused (column.name); <br>
                    <br>
                    테이블 통째로 삭제할 때는. <br>
                    DROP TABLE [TABLE.NAME]; <br>
                    <br>
                    unused 상태의 모든 column을 삭제하는 명령문. <br>
                    ALTER TABLE [TABLE.NAME] DROP UNUSED COLUMNS; <br>
                </p>
            </div>

            <div class="tag2">
                <h2>Transaction, 트랜잭션</h2>
                <br>
                <p>
                    데이터베이스에서 데이터를 처리하는 하나의 단위.<br>
                    쿼리들이 정상적으로 작성되었을 경우 정상적으로 데이터베이스에 반영되고, <br>
                    단 하나라도 잘못되었다면 모든 명령어가 취소되는 방식으로 처리된다.<br>
                    예를들어 현금을 인출하는 과정에 비유하면 카드 인식, 비밀번호 입력, 출금 등<br>
                    모든 과정이 정상적으로 처리될 경우 인출된 금액만큼 통장에서 차감되겠지만, <br>
                    오류, 잘못된 조작, 정전 등 예기치못한 오류가 발생 할 경우,<br>
                    거래가 처음으로 돌아가서 아예 모든것이 취소가 되고 계좌에도 반영되지 않는다.<br>
                    이러한 트랜잭션의 특성으로 인해 데이터베이스의 일관성과 안정성을 유지 할 수 있다.<br>
                    <br>
                    <strong>COMMIT</strong><br>
                    하나의 트랜잭션인 INSERT, DELETE 등의 DML 명령어를 정상적으로 데이터베이스에 반영하는 명령어. <br>
                    <br>
                    <strong>ROLLBACK</strong><br>
                    잘못된 명령어나 잘못된 데이터를 입력하는 등 문제가 발생하였을 때, 하나의 트랜잭션을 취소하는 명령어. <br>
                    만약 데이터베이스가 비정상적으로 종료된다면 자동으로 ROLLBACK이 된다.<br>
                    <br>
                    <strong>SAVEPOINT</strong><br>
                    하나의 트랜잭션을 잘게 분할하여 저장하는 기능.<br>
                    하나의 트랜잭션에서 여러개를 저장 가능하나 S1 지점으로 롤백을 했을경우 S2지점은 자동으로 삭제된다. <br>
                    만약 전체 ROLLBACK을 할 경우 SAVEPOINT는 전체가 삭제된다. <br>
                </p>
            </div>
        </div>

        <div class="tag1 220628">
            <div class="tag2">
                <h2 class="redline">Column. 열. 세로</h2>
                <br>
                <p>
                    위 column 부분의 본래 명령문. <br>
                    <strong>컬럼추가, 열 추가</strong><br>
                    ALTER TABLE [table.name] ADD [column.name] [자료형] DEFAULT [기본값] NOT NULL;
                    <br>
                    <br>
                    <strong>컬럼삭제, 열 삭제</strong><br>
                    ALTER TABLE [table.name] DROP COLUMN [column.name];
                </p>
            </div>

            <div class="tag2">
                <h2>PK 추가</h2>
                <br>
                <p>
                    이미 존재하는 column을 PK로 바꾸는 것. 고유값으로 바꾸는 기능.<br>
                    ALTER TABLE [table.name] <br>
                    ADD CONSTRAINT [PK.name] PRIMARY KEY <br>
                    (column.NAME);<br>
                </p>
            </div>

            <div class="tag2">
                <h2 class="redline">ORACLE 탐색기</h2>
                <br>
                <table>
                    <th>목표</th>
                    <th>명령어</th>
                    <tr>
                        <td>00년00월00일 이후</td>
                        <td>{atom.name} > '00/00/00';</td>
                    </tr>
                    <tr>
                        <td>구간 설정 여러개</td>
                        <td>{atom.name} >= AND {atom.name} <= , {atom.name} BETWEEN 000 AND 000;</td>
                    </tr>
                    <tr>
                        <td>번호가 000,000,000 인</td>
                        <td>{atom.name} IN (000,000,000);</td>
                    </tr>
                    <tr>
                        <td>~를 제외한</td>
                        <td>{atom.name} NOT IN (000,000,000);</td>
                    </tr>
                    <tr>
                        <td>~로 시작하는 (~년도, ~글자로 시작)</td>
                        <td>{atom.name} LIKE ('05%');</td>
                    </tr>
                    <tr>
                        <td>~로 시작하는걸 제외한</td>
                        <td>{atom.name} NOT LIKE ('05%');</td>
                    </tr>
                    <tr>
                        <td>~로 끝나는</td>
                        <td>{atom.name} LIKE ('%05');</td>
                    </tr>
                    <tr>
                        <td>~가 들어간</td>
                        <td>{atom.name} LIKE ('%05%');</td>
                    </tr>
                    <tr>
                        <td>~가 없는, ~가 0인</td>
                        <td>{atom.name} IS NULL; 얘는 꼭 IS랑 같이써야함.</td>
                    </tr>
                    <tr>
                        <td>~가 있는, ~가 1인</td>
                        <td>{atom.name} IS NOT NULL;</td>
                    </tr>
                    <tr>
                        <td>조건이 여러개인 경우</td>
                        <td>AND, OR을 적절히 사용</td>
                    </tr>
                    <tr>
                        <td>a,b,c 가 아닌</td>
                        <td>{atom.name} NOT IN ('a','b','c');</td>
                    </tr>
                    <tr>
                        <td>~사이에 포함되지 않는</td>
                        <td>{atom.name} NOT BETWEEN 000 AND 000;</td>
                    </tr>
                    <tr>
                        <td>~사이에 포함되는</td>
                        <td>{atom.name} BETWEEN 000 and 000;</td>
                    </tr>
                    <tr>
                        <td>소문자로 검색 또는 출력</td>
                        <td>LOWER( {atom.name} );</td>
                    </tr>
                    <tr>
                        <td>대문자로 검색 또는 출력</td>
                        <td>UPPER( {atom.name} );</td>
                    </tr>
                    <tr>
                        <td>a, b 합치기</td>
                        <td>a || b 만약 중간에 공백이 필요하면 ' '을 넣어준다.</td>
                    </tr>
                    <tr>
                        <td>문자열 'a'보다 크고 'b'보다 작은 것 검색</td>
                        <td>SUBSTR( {atom.name},1,1 ) > 'a' AND SUBSTR( {atom.name},1,1) < 'b'</td>
                    </tr>
                    <tr>
                        <td>이름순으로 정렬, 오름차순</td>
                        <td>ORDER BY {atom.name};</td>
                    </tr>
                    <tr>
                        <td>~의 길이 구하기</td>
                        <td>LENGTH({atom.name});</td>
                    </tr>
                    <tr>
                        <td>~중 문자열 'a'의 위치 출력</td>
                        <td>SELECT ~ {atom.name}, INSTR({atom.name},'a',1,1) FROM ~ </td>
                    </tr>
                    <tr>
                        <td>전화번호 표현패턴 정규식</td>
                        <td>^010-\d{3,4}-\d{4}, 4글자 = d{4}, 3글자 또는 4글자 d{3,4}$</td>
                    </tr>
                </table>
                <br>
                <p>
                    SELECT 대상이 숫자인 경우, SELECT AVG({atom.name}), MAX({atom.name}), MIN, SUM 등 사칙연산의 사용이 가능하다. <br>
                    MIN, MAX는 모든 자료형에 사용이 가능하다.
                </p>
            </div>

            <div class="tag2">
                <h2>ORDER BY</h2>
                <br>
                <p>
                    SELECT A <br>
                    FROM B  <br>
                    ORDER BY {atom.name} ASC 또는 DESC (작은것부터, 큰것부터) <br>
                    <br>
                    ORDER BY {atom.name1} ASC, {atom.name2} DESC; 처럼 다양하게 2개, 3개씩 합쳐서 사용 가능
                </p>
            </div>

            <div class="tag2">
                <h2>GROUP BY</h2>
                <br>
                <p>
                    <div class="groupbyChart"></div>
                    <br>
                    SELECT [GROUP BY 절에 지정된 컬럼1] [GROUP BY별로 집계할 값]<br>
                    FROM [테이블 명]<br>
                    GROUP BY [ 그룹으로 묶을 컬럼 값 ]<br>
                    <br>
                    <strong>예시, 학급별 성적집계</strong>  <br>
                    SELECT CLASS, SUM(SCORE) <br>
                    FROM TBL_REPORT_CARD<br>
                    GROUP BY CLASS;
                    <br>
                    <br>
                    <strong class="stSt">HAVING</strong> <br>
                    GROUP BY로 집계된 값에서 WHERE을 추가한다고 생각하면 된다. 만약 GROUP BY로 SUM을 집계 했다면 그 SUM에 크거나 작거나 하는 수식 조건문을 추가하는 것. GROUP BY 만의 WHERE.
                    <br>
                    <strong class="redline">복잡한 명령어를 다루기 좋으며, 한번 집합시킨 데이터 안에서 집합을 한번 더 걸어서 더욱더 복잡한 집합을 걸 수 있다.</strong> 
                </p>
            </div>
        </div>

        <div class="tag1 220629">
            <div class="tag2">
                <h2>ROWNUM</h2>
                <br>

                <p>
                    자동적으로 시스템이 부여하는 ID값으로 볼 수 있다. 따로 생성하지 않아도 자동으로 들어있으며, 무조건 1부터만 시작 가능하다.<br>
                    순서를 부여한다는 특성으로 인해 ORDER BY와 유사성을 갖지만 둘을 함께 사용하면 순서가 엉망이 된다. <br>
                    이를 방지하기 위해서는 쿼리 안에 서브 쿼리를 만들어서 ORDER BY를 먼저 적용 시킨 후 ROWNUM을 적용하면 해결 가능하다. <br>
                    <br>
                    ROWNUM이 걸린 완성된 쿼리에서 ORDER BY를 적용해서 DESC를 사용하면 ROWNUM의 역순을 만들 수 도 있다.
                </p>
            </div>

            <div class="tag2">
                <h2>함수</h2>
                <br>
                <p>
                    SELECT LENGTU('HELLO')FROM DUAL
                </p>
            </div>
        </div>




    </section>

    <footer>
        <!-- <h1>ORACLE DATABASE</h1> -->
        <div class="footerLogo"></div>
    </footer>
</body>
</html>