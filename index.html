<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ORACLE DATABASE Diary</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <!-- <h1>ORACLE DATABASE</h1> -->
        <div class="logo"></div>
    </header>

    <section>
        <div class="tag1 220624">
            <h1>220624</h1>

            <div class="tag2">
                <h2>Schema</h2>
                <p>
                    서로 연관된 표들을 그룹핑하는 일종의 디렉토리. (스키마에 속한 표들이 어떤 정보를 갖는지 설명하는 것.)
                </p>
            </div>

            <div class="tag2">
                <h2>관리자 및 사용자 생성</h2>
                <p>
                    관리자. System As System DataBase Admin <br>
                    cmd 창에서 sqlplus를 입력하여 오라클을 실행 후, <br>
                    sys AS SYSDBA 후 엔터 하면 password 입력하라고 뜨는데 그냥 비워두고 다시 Enter 눌러도됨 <br>
    
                    <br>
                    사용자 <br>
                    CREATE USER [ID] IDENTIFIED BY [PWD] <br>
                    그러나 생성이 안될경우 alter session set "_ORACLE_SCRIPT"=true; 명령어를 실행하여 세션을 변경해준다. ORACLE 11g 에서 사용하는 방법임. <br>
                    이후 생성된 사용자 계정에 권한을 부여해줘야 계정을 사용할 수 있게 된다.  <br>
                    우선 관리자로 로그인한 뒤 GRANT DBA TO [ID]; 를 하면 권한을 줄 수 있다. <br>
                    중간의 DBA는 어떤 권한을 줄지를 선택해주는 단어이다. 데이터베이스는 관리자와 사용자의 권한을 나눠서 이원화시켜 관리하는것이 바람직하기때문에 DBA라는 최상위 권한을 주는것은 옳지 않지만, 여기서는 공부를 위해 사용하므로 DBA라는 높은 권한을 주었다. <br>
                </p>
            </div>

            <div class="tag2">
                <h2>정의</h2>
                <p>
                    DDL - CREATE / ALTER / DROP <br>
                    DML - INSERT / SELECT / UPDATE / DELETE -> CRUD <br>
                    DCL - GRANT / REVOKE <br>
                </p>
            </div>

            <div class="tag2">
                <h2>Table 생성</h2>
                <p>
                    CREATE TABLE topic ( <br>
                    &emsp;    id  NUMBER NOT NULL, <br>
                    &emsp;    title VARCHAR2(50) NOT NULL, <br>
                    &emsp;    description VARCHAR2(4000) NULL, <br>
                    &emsp;    created DATE NOT NULL <br>
                    ); <br>
                    설명 <br>
                    NUMBER - 숫자만 들어옴  <br>
                    VARCHAR2(num) - 괄호안의 글자수 까지만 문자열이 들어옴  <br>
                    DATA - 날짜가 들어오는 ORACLE 구문. <br>
                    NOT NULL - 비어있어선 안된다.   <br>
                    NULL - 비어있어도 된다. 이 경우에 그냥 NULL도 안써도됨. <br>
                </p>
            </div>

            <div class="tag2">
                <h2>생성된 테이블 확인</h2>
                <p>
                    테이블을 선택하는 방법 <br>
                    SELECT table_name FROM all_tables WHERE OWNER = 'AYH'
                </p>
            </div>

            <div class="tag2">
                <h2 class="redline">행 추가, CREATE</h2>
                <p>
                    INSERT INTO topic <br>
                    &emsp;   (id,title,description,created) <br>
                    &emsp;   VALUES <br>
                    &emsp;   (1,'ORACLE','ORACLE is ...',SYSDATE); <br>
                    
                    이후 commit; 을 해줘야함. commit을 하지 않으면 행을 몇개를 추가하든 실제로 반영이 되지는 않음. 깃허브의 psuh를 생각해보자.
                </p>
            </div>

            <div class="tag2">
                <h2>SQL</h2>
                <p>
                    Structured Query Language.<br>
                    구조화된 정보를 처리하도록 요청하는 컴퓨팅 언어.
                </p>
            </div>

            <div class="tag2">
                <h2 class="redline">행 읽기, Read</h2>
                <p>
                    전체 읽기 <br>
                    SELECT * FROM topic; <br>
                    특정 열 값만 읽기 <br>
                    SELECT id, title, created FROM topic; <br>
                    특정 행 값만 읽기 <br>
                    SELECT * FROM topic WHERE id = 1; <br>
                    SELECT * FROM topic WHERE id > 1; <br>
                    특정 행렬만 읽기(가로 세로 모두 필터링) <br>
                    SELECT id, title, created FROM topic WHERE id = 1;
                </p>
            </div>

            <div class="tag2">
                <h2>정렬</h2>
                <p>
                    높은 숫자부터 정렬 <br>
                    SELECT * FROM topic ORDER BY id DESC; <br>
                    낮은 숫자부터 정렬 <br>
                    SELECT * FROM topic ORDER BY id ASC; <br>
                    숫자로 할꺼면 id, 타이틀로 할꺼면 title로 하면 되며 알파벳 순서로 DESC, ASC를 따른다.<br>
                    SELECT * FROM topic <br>
                    &emsp;    OFFSET 1 ROWS <br>
                    &emsp;    FETCH NEXT 2 ROWS ONLY; <br>
                    OFFSET - 특정 행의 "다음" 부터 출력. 즉 OFFSET 1을 하면 2부터 출력됨. <br>
                    FETCH - 다음 [num] 개의 행만 출력
                </p>
            </div>

            <div class="tag2">
                <h2 class="redline">행 수정, UPDATE</h2>
                <p>
                    UPDATE topic <br>
                    &emsp;        SET<br>
                    &emsp;&emsp;            title = 'MSSQL',<br>
                    &emsp;&emsp;           description = 'MSSQL is...'<br>
                    &emsp;        WHERE<br>
                    &emsp;&emsp;            id = 3;<br>
                    무엇을 수정할지가 SET에 먼저 나온 뒤, 어디에 있는걸 수정할지 주소값을 입력해줘야한다. <br>
                    UPDATE와 DELETE는 무언가 바뀌는 행위 이므로 수정한 뒤 commit;을 해줘야 반영된다. <br>
                    수정과 삭제는 매우매우 위험한 작업이므로 굉장히 주의깊게 해야한다.
                </p>
            </div>

            <div class="tag2">
                <h2 class="redline">행 삭제, DELETE</h2>
                <p>
                    DELETE FROM topic WHERE id = 3; <br>
                    특정한 행을 삭제하는 것. 만약 WHERE id를 지정해주지 않으면 모든 데이터가 날라가버려서 큰일이 발생한다.
                </p>
            </div>

            <div class="tag2">
                <h2>테이블 통째로 삭제</h2>
                <p>
                    DROP TABLE topic; <br>
                    테이블을 전부 삭제하고 나서는 commit;을 해줄 필요는 없다.
                </p>
            </div>

            <div class="tag2">
                <h2>PRIMARY KEY. 고유값</h2>
                <p>
                    CREATE TABLE topic ( <br>
                    &emsp;    id  NUMBER NOT NULL, <br>
                    &emsp;    title VARCHAR2(50) NOT NULL, <br>
                    &emsp;    description VARCHAR2(4000) NULL, <br>
                    &emsp;    created DATE NOT NULL <br>
                    &emsp;    CONSTRAINT PK_TOPIC PRIMARY KEY(원하는거 id, title 등등) <br>
                    ); <br>
                    예를들어 id에 PK_TOPIC이라 명명한 PRIMARY KEY를 설정하면 고유한 귀속이 걸려서 같은 넘버로는 행을 추가 할 수 없다. <br>
                    PRIMARY KEY를 지정한 값을 통해 자료를 찾으면 검색 속도가 매우매우 빠르다. <br>
                    만약 id에 PK를 지정하고 1번에 값을 다시 INSERT 하면 무결성제약조건에 위배된다는 메세지가 뜨면서 추가가 되지 않는다. 
                </p>
            </div>
        </div>

        <div class="tag1 220627">
            <h1>220627</h1>

            <div class="tag2">
                <h2>SEQUENCE</h2>
                <p>
                    자동적으로 값을 부여해주는 기능.<br>
                    예를 들어 id값을 PRIMARY KEY 기능으로 부여를 해주었을때 새로 데이터를 INSERT 할 때 마다 <br>
                    자동적으로 가장 높은값으로 부여해주는 기능이다. 즉, PRIMARY KEY 기능과 한 세트로 동작한다.<br>
                    CREATE SEQUENCE [NAME]; 을 입력하여 시퀀스를 생성한 후 INSERT 명령문의 id값 또는 원하는 부분에<br>
                    [NAME].NEXTVAL 을 입력해주면 자동으로 id값이 가장 높은 값으로 부여되는 명령문이 완성된다. <br>
                    1을 더하면서 높여주는 값, 10을 더하면서 높여주는 값 등 다양한 옵션을 이용할 수 있음. <br>
                    만약 현재 시퀀스의 가장 높은 값을 알고 싶으면 SELECT SEQ_topicPRIM.CURRVAL FROM DUAL; 을 명령하면 알 수 있음. <br>
                    SELECT SEQ_topicPRIM.CURRVAL FROM topicPRIM; 을 사용해도 알 수 있지만 시퀀스의 값 만큼의 행이 생성되므로 그냥 DUAL이 편하다.
                </p>
            </div>

            <div class="tag2">
                <h2 class="redline">분해</h2>
                <p>
                    데이터를 다룰때는 이를 쪼개서 분산시킬 수 있다. 특정 분류를 코드화해서 보관하면 추후에 엄청난 양의 데이터를 수정해야하는 상황이 발생할 때, <br>
                    매우 간편하게 이를 동시에 전부 바꿀 수 있게 되므로 분류와 조합을 잘 하는것이 중요하다.
                </p>
            </div>

            <div class="tag2">
                <h2 class="redline">조립, Join</h2>
                <p>
                    데이터를 분해해두면 추후 관리하기는 좋지만 표를 보기에는 좋지 않다. 그러므로 이를 조립을 해서 보여주면 관리의 용이함과 표의 직관성을 둘 다 잡을 수 있다. <br>
                    SELECT * FROM topic LEFT JOIN author ON topic.author_id = author.id; <br>
                    왼쪽에 topic을, 오른쪽에 author표를 배치하는 것. topic의 author_id와 author의 id가 같은 것을 매칭시켜서 왼쪽과 오른쪽에 각기 배치하는 방법이다. <br>
                    이러한 Relation 기능들 덕에 지난 수십년간 ORACLE과 같은 관계형 데이터베이스가 컴퓨터공학을 지배할 수 있었다. <br>

                    SELECT <br>
                    &emsp;    T.id TOPIC_ID, <br>
                    &emsp;    title,<br>
                    &emsp;    T.description,<br>
                    &emsp;    created,<br>
                    &emsp;    name,<br>
                    &emsp;    PROFILE<br>
                    FROM topic T<br>
                    &emsp;    LEFT JOIN author A <br>
                    &emsp;    ON T.author_id = A.id<br>
                    ; <br>

                    SELECT 아래에는 보고싶은 데이터. T.id 뒤의 TOPIC_ID는 데이터 칸에 들어올 별명.  <br>
                    topic T 는 앞으로 topic을 T로 대신하겠다는 의미. 워크시트에서 T를 topic대신 쓸 수 있다.
                    FROM 아래는 합쳐지는 위치에 대한 정의. LEFT는 원래 있는 T의 기준 위치이며 JOIN 뒤에 오는것은 어떤 테이블을 합칠것인가에 대한 명령문.<br>
                    ON 은 합쳐지는 조건에 대한 정의. 위 워크시트에서는 T의 author_id와 A의 id가 같을때만 합쳐지도록 설정한것이다.
                </p>
            </div>
        </div>
    </section>

    <footer>
        <h1>ORACLE DATABASE</h1>
    </footer>
</body>
</html>